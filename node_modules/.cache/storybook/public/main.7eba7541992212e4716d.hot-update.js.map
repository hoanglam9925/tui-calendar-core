{"version":3,"file":"main.7eba7541992212e4716d.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;AAUA;AAuDA;AACA;AACA;AAGA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;;;;AAOA;AA2BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AAEA;AACA;AACA;;;;AACA;AACA;AACA;AAEA;AACA;AACA;;;;AACA;AACA;AACA;AAEA;AACA;AACA;;;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AATA;AAWA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3BA;AA6BA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;;;;AAGA;AACA;AACA;;;AA3UA;AAoEA;AACA;AAFA;AAnEA;AA6UA;AAAA;AACA;AAAA;AAAA;AAEA;AACA","sources":["webpack://@toast-ui/calendar/./src/model/eventModel.ts"],"sourcesContent":["import { collidesWith } from '@src/helpers/events';\nimport EventUIModel from '@src/model/eventUIModel';\nimport TZDate from '@src/time/date';\nimport { compare, MS_PER_DAY, parse, toEndOfDay, toStartOfDay } from '@src/time/datetime';\nimport { stamp } from '@src/utils/stamp';\nimport { isString } from '@src/utils/type';\n\nimport type {\n  DateType,\n  EventCategory,\n  EventObject,\n  EventObjectWithDefaultValues,\n  EventState,\n} from '@t/events';\n\nexport default class EventModel implements Omit<EventObjectWithDefaultValues, '__cid'> {\n  id = '';\n\n  calendarId = '';\n\n  title = '';\n\n  body = '';\n\n  isAllday = false;\n\n  start: TZDate = new TZDate();\n\n  end: TZDate = new TZDate();\n\n  goingDuration = 0;\n\n  comingDuration = 0;\n\n  location = '';\n\n  attendees: string[] = [];\n\n  category: EventCategory = 'time';\n\n  dueDateClass = '';\n\n  recurrenceRule = '';\n\n  state: EventState = 'Busy';\n\n  isVisible = true;\n\n  isPending = false;\n\n  isFocused = false;\n\n  isReadOnly = false;\n\n  isPrivate = false;\n\n  color?: string;\n\n  backgroundColor?: string;\n\n  dragBackgroundColor?: string;\n\n  borderColor?: string;\n\n  customStyle = {};\n\n  raw: any = null;\n\n  userData?: any\n\n  /**\n   * whether the event includes multiple dates\n   */\n  hasMultiDates = false;\n\n  constructor(event: EventObject = {}) {\n    // initialize model id\n    stamp(this);\n\n    this.init(event);\n  }\n\n  static schema = {\n    required: ['title'],\n    dateRange: ['start', 'end'],\n  };\n\n  init({\n    id = '',\n    calendarId = '',\n    title = '',\n    body = '',\n    isAllday = false,\n    start = new TZDate(),\n    end = new TZDate(),\n    goingDuration = 0,\n    comingDuration = 0,\n    location = '',\n    attendees = [],\n    category = 'time',\n    dueDateClass = '',\n    recurrenceRule = '',\n    state = 'Busy',\n    isVisible = true,\n    isPending = false,\n    isFocused = false,\n    isReadOnly = false,\n    isPrivate = false,\n    color,\n    backgroundColor,\n    dragBackgroundColor,\n    borderColor,\n    customStyle = {},\n    raw = null,\n  }: EventObject = {}) {\n    this.id = id;\n    this.calendarId = calendarId;\n    this.title = title;\n    this.body = body;\n    this.isAllday = category === 'allday' ? true : isAllday;\n    this.goingDuration = goingDuration;\n    this.comingDuration = comingDuration;\n    this.location = location;\n    this.attendees = attendees;\n    this.category = category;\n    this.dueDateClass = dueDateClass;\n    this.recurrenceRule = recurrenceRule;\n    this.state = state;\n    this.isVisible = isVisible;\n    this.isPending = isPending;\n    this.isFocused = isFocused;\n    this.isReadOnly = isReadOnly;\n    this.isPrivate = isPrivate;\n    this.color = color;\n    this.backgroundColor = backgroundColor;\n    this.dragBackgroundColor = dragBackgroundColor;\n    this.borderColor = borderColor;\n    this.customStyle = customStyle;\n    this.raw = raw;\n\n    if (this.isAllday) {\n      this.setAlldayPeriod(start, end);\n    } else {\n      this.setTimePeriod(start, end);\n    }\n\n    if (category === 'milestone' || category === 'task') {\n      this.start = new TZDate(this.end);\n    }\n  }\n\n  setAlldayPeriod(start?: DateType, end?: DateType) {\n    // If it is an all-day, only the date information of the string is used.\n    let startedAt: TZDate;\n    let endedAt: TZDate;\n\n    if (isString(start)) {\n      startedAt = parse(start.substring(0, 10));\n    } else {\n      startedAt = new TZDate(start || Date.now());\n    }\n\n    if (isString(end)) {\n      endedAt = parse(end.substring(0, 10));\n    } else {\n      endedAt = new TZDate(end || this.start);\n    }\n\n    this.start = startedAt;\n    this.start.setHours(0, 0, 0);\n    this.end = (endedAt as TZDate) || new TZDate(this.start);\n    this.end.setHours(23, 59, 59);\n  }\n\n  setTimePeriod(start?: DateType, end?: DateType) {\n    this.start = new TZDate(start || Date.now());\n    this.end = new TZDate(end || this.start);\n\n    if (!end) {\n      this.end.setMinutes(this.end.getMinutes() + 30);\n    }\n\n    // if over 24 hours\n    this.hasMultiDates = this.end.getTime() - this.start.getTime() > MS_PER_DAY;\n  }\n\n  /**\n   * @returns {TZDate} render start date.\n   */\n  getStarts() {\n    return this.start;\n  }\n\n  /**\n   * @returns {TZDate} render end date.\n   */\n  getEnds() {\n    return this.end;\n  }\n\n  /**\n   * @returns {number} instance unique id.\n   */\n  cid(): number {\n    return stamp(this);\n  }\n\n  /**\n   * Check two  are equals (means title, isAllday, start, end are same)\n   * @param {EventModel}  event model instance to compare.\n   * @returns {boolean} Return false when not same.\n   */\n  // eslint-disable-next-line complexity\n  equals(event: EventModel) {\n    if (this.id !== event.id) {\n      return false;\n    }\n\n    if (this.title !== event.title) {\n      return false;\n    }\n\n    if (this.body !== event.body) {\n      return false;\n    }\n\n    if (this.isAllday !== event.isAllday) {\n      return false;\n    }\n\n    if (compare(this.getStarts(), event.getStarts()) !== 0) {\n      return false;\n    }\n\n    if (compare(this.getEnds(), event.getEnds()) !== 0) {\n      return false;\n    }\n\n    if (this.color !== event.color) {\n      return false;\n    }\n\n    if (this.backgroundColor !== event.backgroundColor) {\n      return false;\n    }\n\n    if (this.dragBackgroundColor !== event.dragBackgroundColor) {\n      return false;\n    }\n\n    if (this.borderColor !== event.borderColor) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * return duration between start and end.\n   * @returns {number} duration milliseconds (UTC)\n   */\n  duration(): number {\n    const start = Number(this.getStarts());\n    const end = Number(this.getEnds());\n    let duration: number;\n\n    if (this.isAllday) {\n      duration = Number(toEndOfDay(end)) - Number(toStartOfDay(start));\n    } else {\n      duration = end - start;\n    }\n\n    return duration;\n  }\n\n  valueOf() {\n    return this;\n  }\n\n  /**\n   * Returns true if the given EventModel coincides with the same time as the\n   * calling EventModel.\n   * @param {EventModel | EventUIModel} event The other event to compare with this EventModel.\n   * @param {boolean = true} usingTravelTime When calculating collision, whether to calculate with travel time.\n   * @returns {boolean} If the other event occurs within the same time as the first object.\n   */\n  collidesWith(event: EventModel | EventUIModel, usingTravelTime = true) {\n    event = event instanceof EventUIModel ? event.model : event;\n\n    return collidesWith({\n      start: Number(this.getStarts()),\n      end: Number(this.getEnds()),\n      targetStart: Number(event.getStarts()),\n      targetEnd: Number(event.getEnds()),\n      goingDuration: this.goingDuration,\n      comingDuration: this.comingDuration,\n      targetGoingDuration: event.goingDuration,\n      targetComingDuration: event.comingDuration,\n      usingTravelTime, // Daygrid does not use travelTime, TimeGrid uses travelTime.\n    });\n  }\n\n  toEventObject(): EventObjectWithDefaultValues {\n    return {\n      id: this.id,\n      calendarId: this.calendarId,\n      __cid: this.cid(),\n      title: this.title,\n      body: this.body,\n      isAllday: this.isAllday,\n      start: this.start,\n      end: this.end,\n      goingDuration: this.goingDuration,\n      comingDuration: this.comingDuration,\n      location: this.location,\n      attendees: this.attendees,\n      category: this.category,\n      dueDateClass: this.dueDateClass,\n      recurrenceRule: this.recurrenceRule,\n      state: this.state,\n      isVisible: this.isVisible,\n      isPending: this.isPending,\n      isFocused: this.isFocused,\n      isReadOnly: this.isReadOnly,\n      isPrivate: this.isPrivate,\n      color: this.color,\n      backgroundColor: this.backgroundColor,\n      dragBackgroundColor: this.dragBackgroundColor,\n      borderColor: this.borderColor,\n      customStyle: this.customStyle,\n      raw: this.raw,\n    };\n  }\n\n  getColors() {\n    return {\n      color: this.color,\n      backgroundColor: this.backgroundColor,\n      dragBackgroundColor: this.dragBackgroundColor,\n      borderColor: this.borderColor,\n    };\n  }\n}\n\n// export function isBackgroundEvent({ model }: EventUIModel) {\n//   return model.category === 'background';\n// }\n\nexport function isTimeEvent({ model }: EventUIModel) {\n  const { category, isAllday, hasMultiDates } = model;\n\n  return category === 'time' && !isAllday && !hasMultiDates;\n}\n"],"names":[],"sourceRoot":""}